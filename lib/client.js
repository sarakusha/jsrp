// Generated by CoffeeScript 1.6.3
(function() {
  var Client, SRP, crypto, transform;

  transform = require('./transform');

  SRP = require('./srp');

  crypto = require('crypto');

  Client = (function() {
    function Client() {}

    Client.prototype.init = function(options, callback) {
      var length,
        _this = this;
      this.IBuf = new Buffer(options.username);
      this.PBuf = new Buffer(options.password);
      length = options.length || 4096;
      this.srp = new SRP(length);
      return this.srp.a(function(err, a) {
        _this.aInt = a;
        _this.ABuf = _this.srp.A({
          a: _this.aInt
        });
        return callback();
      });
    };

    Client.prototype.debugInit = function(options, callback) {
      var length;
      this.IBuf = new Buffer(options.username);
      this.PBuf = new Buffer(options.password);
      length = options.length || 4096;
      this.srp = new SRP(length);
      this.aInt = transform.buffer.toBigInteger(options.a);
      this.ABuf = this.srp.A({
        a: this.aInt
      });
      return callback();
    };

    Client.prototype.getPublicKey = function() {
      return this.ABuf.toString('hex');
    };

    Client.prototype.setSalt = function(hexSalt) {
      this.saltBuf = new Buffer(hexSalt, 'hex');
      return this.xInt = this.srp.x({
        I: this.IBuf,
        P: this.PBuf,
        salt: this.saltBuf
      });
    };

    Client.prototype.setServerPublicKey = function(hexB) {
      var BBigInt;
      this.BBuf = new Buffer(hexB, 'hex');
      BBigInt = transform.buffer.toBigInteger(this.BBuf);
      if (this.srp.isZeroWhenModN(BBigInt)) {
        throw Error('Invalid B value, abort');
      }
      this.uInt = this.srp.u({
        A: this.ABuf,
        B: this.BBuf
      });
      this.SBuf = this.srp.clientS({
        B: transform.buffer.toBigInteger(this.BBuf),
        a: this.aInt,
        u: this.uInt,
        x: this.xInt
      });
      return this.KBuf = this.srp.K({
        S: this.SBuf
      });
    };

    Client.prototype.getProof = function() {
      this.M1Buf = this.srp.M1({
        A: this.ABuf,
        B: this.BBuf,
        K: this.KBuf
      });
      return this.M1Buf.toString('hex');
    };

    Client.prototype.checkServerProof = function(hexM2) {
      var ServerM2Buf, result;
      ServerM2Buf = new Buffer(hexM2, 'hex');
      this.M2Buf = this.srp.M2({
        A: this.ABuf,
        M: this.M1Buf,
        K: this.KBuf
      });
      result = this.M2Buf.toString('hex') === ServerM2Buf.toString('hex');
      return result;
    };

    Client.prototype.getSharedKey = function() {
      return this.KBuf.toString('hex');
    };

    Client.prototype.createVerifier = function(callback) {
      var _this = this;
      return this.srp.generateSalt(function(err, salt) {
        var result;
        _this.saltBuf = salt;
        result = _this.srp.v({
          I: _this.IBuf,
          P: _this.PBuf,
          salt: _this.saltBuf
        });
        result = result.toString('hex');
        return callback(null, {
          verifier: result,
          salt: _this.getSalt()
        });
      });
    };

    Client.prototype.getSalt = function() {
      return this.saltBuf.toString('hex');
    };

    Client.prototype.encrypt = function(data, encoding) {
      var cipher;
      if (encoding == null) {
        encoding = 'utf8';
      }
      cipher = crypto.createCipher('aes256', this.KBuf);
      return cipher.update(data, encoding, 'hex') + cipher.final('hex');
    };

    Client.prototype.decrypt = function(hex, encoding) {
      var decipher;
      if (encoding == null) {
        encoding = 'utf8';
      }
      decipher = crypto.createDecipher('aes256', this.KBuf);
      return decipher.update(hex, 'hex', encoding) + decipher.final(encoding);
    };

    return Client;

  })();

  module.exports = Client;

}).call(this);
